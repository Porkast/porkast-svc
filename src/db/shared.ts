import { Podcast } from "podcast"
import prisma from "./prisma.client"
import { queryUserListenLaterList } from "./listen_later"
import { queryPlaylistByPlaylistId, queryPlaylistItemsByPlaylistId } from "./playlist"
import { UserPlaylistItemDto } from "../models/playlist"
import { FeedItem } from "../models/feeds"
import { UserInfo } from "../api/user/types"
import { UserListenLaterDto } from "../models/listen_later"
import { queryKeywordSubscriptionFeedItemList, queryUserKeywordSubscriptionDetail } from "./subscription"

export const generateListenLaterRSSXml = async (userId: string): Promise<string> => {
    let rssStr: string = ''

    const userInfo = await prisma.user_info.findUnique({
        where: {
            id: userId
        }
    })

    if (!userInfo) {
        throw new Error('User not found')
    }

    const queryListData = await queryUserListenLaterList(userId, 200, 0)
    const serverUserInfo: UserInfo = {
        userId: userInfo.id,
        nickname: userInfo.nickname || '',
        email: userInfo.email || '',
        phone: userInfo.phone || '',
        avatar: userInfo.avatar || '',
        telegramId: userInfo.telegram_id || '',
        password: "",
        regDate: userInfo.reg_date || new Date(),
        updateDate: userInfo.update_date || new Date()
    }

    const nickname = serverUserInfo.nickname
    const feed = new Podcast({
        title: `${nickname}\`s Porkast Listen Later`,
        language: queryListData[0]?.country || 'en',
        description: `${nickname}\`s Porkast Listen Later, generated by Porkast`,
        feedUrl: `https://porkast.com/api/rss/listenlater/${userInfo.id}`,
        siteUrl: 'https://porkast.com',
        imageUrl: 'https://porkast.com/porkast-text-logo.png',
        author: nickname,
        managingEditor: nickname,
        webMaster: 'Porkast',
        copyright: `${nickname}@Porkast`,
        itunesAuthor: nickname,
        itunesOwner: { email: userInfo.email || '', name: nickname },
        itunesSubtitle: `${nickname}\`s Porkast Listen Later`,
        itunesImage: 'https://porkast.com/porkast-text-logo.png',
    })

    queryListData.forEach((item: UserListenLaterDto) => {
        feed.addItem({
            title: item.title,
            description: item.description,
            url: item.link,
            guid: item.guid,
            author: item.author,
            date: item.pub_date,
            enclosure: {
                url: item.enclosure_url,
                size: parseInt(item.enclosure_length || '0'),
                type: item.enclosure_type
            },
            itunesAuthor: item.author,
            itunesExplicit: false,
            itunesSummary: item.description,
            itunesImage: item.image_url,
            itunesSeason: parseInt(item.season || '0'),
            itunesDuration: item.duration,
            itunesNewFeedUrl: item.feed_link
        })
    })

    rssStr = feed.buildXml()

    return rssStr
}

export const generatePlaylistRSSXml = async (userId: string, playlistId: string): Promise<string> => {

    let rssStr: string = ''
    const userInfo = await prisma.user_info.findUnique({
        where: {
            id: userId
        }
    })

    if (!userInfo) {
        throw new Error('User not found')
    }
    const serverUserInfo: UserInfo = {
        userId: userInfo.id,
        nickname: userInfo.nickname || '',
        email: userInfo.email || '',
        phone: userInfo.phone || '',
        avatar: userInfo.avatar || '',
        telegramId: userInfo.telegram_id || '',
        password: "",
        regDate: userInfo.reg_date || new Date(),
        updateDate: userInfo.update_date || new Date()
    }
    const nickname = serverUserInfo.nickname

    const playlistInfoQuery = await queryPlaylistByPlaylistId(playlistId)
    if (!playlistInfoQuery) {
        throw new Error('Playlist not found')
    }

    const playlistItemList = await queryPlaylistItemsByPlaylistId(playlistId)

    const feed = new Podcast({
        title: `${playlistInfoQuery.PlaylistName}`,
        language: 'en',
        description: `${playlistInfoQuery.Description}\n\n${nickname}\`s Porkast Playlist , generated by Porkast`,
        feedUrl: `https://porkast.com/api/rss/playlist/${playlistId}/${userInfo.id}`,
        siteUrl: 'https://porkast.com',
        imageUrl: 'https://porkast.com/porkast-text-logo.png',
        author: nickname,
        managingEditor: nickname,
        webMaster: 'Porkast',
        copyright: `${nickname}@Porkast`,
        itunesAuthor: nickname,
        itunesOwner: { email: userInfo.email || '', name: nickname },
        itunesSubtitle: `${nickname}\`s Porkast Playlist, ${playlistInfoQuery.PlaylistName}`,
        itunesImage: 'https://porkast.com/porkast-text-logo.png',
    })

    playlistItemList.forEach((item: UserPlaylistItemDto) => {
        feed.addItem({
            title: item.Title,
            description: item.Description,
            url: item.Link,
            guid: item.GUID,
            author: item.Author,
            date: item.PubDate,
            enclosure: {
                url: item.EnclosureUrl,
                size: parseInt(item.EnclosureLength || '0'),
                type: item.EnclosureType
            },
            itunesAuthor: item.Author,
            itunesExplicit: false,
            itunesSummary: item.Description,
            itunesImage: item.ImageUrl,
            itunesSeason: parseInt(item.Season || '0'),
            itunesDuration: item.Duration,
            itunesNewFeedUrl: item.FeedLink
        })
    })

    rssStr = feed.buildXml()

    return rssStr
}

export const generateSubscriptionRSS = async (userId: string, keyword: string): Promise<string> => {

    let rssStr: string = ''
    const userInfo = await prisma.user_info.findUnique({
        where: {
            id: userId
        }
    })
    if (!userInfo) {
        throw new Error('User not found')
    }

    const serverUserInfo: UserInfo = {
        userId: userInfo.id,
        nickname: userInfo.nickname || '',
        email: userInfo.email || '',
        phone: userInfo.phone || '',
        avatar: userInfo.avatar || '',
        telegramId: userInfo.telegram_id || '',
        password: "",
        regDate: userInfo.reg_date || new Date(),
        updateDate: userInfo.update_date || new Date()
    }
    const nickname = serverUserInfo.nickname

    const subsciptionInfo = await queryUserKeywordSubscriptionDetail(userId, keyword)
    if (!subsciptionInfo) {
        throw new Error('Subscription not found')
    }

    const decodeKeyword = decodeURIComponent(keyword)
    
    const subsciptionItemList = await queryKeywordSubscriptionFeedItemList(userId, keyword, subsciptionInfo.Source, subsciptionInfo.Country, subsciptionInfo.ExcludeFeedId, 0, 200)

    const feed = new Podcast({
        title: `${subsciptionInfo.Keyword}`,
        language: 'en',
        description: `${nickname}\`s Porkast Search Subscription with ${subsciptionInfo.Keyword}, generated by Porkast`,
        feedUrl: `https://porkast.com/api/rss/subscription/${decodeKeyword}/${userInfo.id}`,
        siteUrl: 'https://porkast.com',
        imageUrl: 'https://porkast.com/porkast-text-logo.png',
        author: nickname,
        managingEditor: nickname,
        webMaster: 'Porkast',
        copyright: `${nickname}@Porkast`,
        itunesAuthor: nickname,
        itunesOwner: { email: userInfo.email || '', name: nickname },
        itunesSubtitle: `${nickname}\`s Porkast Search Subscription with ${subsciptionInfo.Keyword}, generated by Porkast`,
        itunesImage: 'https://porkast.com/porkast-text-logo.png',
    })

    subsciptionItemList.forEach((item: FeedItem) => {
        feed.addItem({
            title: item.Title,
            description: item.Description,
            url: item.Link,
            guid: item.GUID,
            author: item.Author,
            date: item.PubDate,
            enclosure: {
                url: item.EnclosureUrl,
                size: parseInt(item.EnclosureLength || '0'),
                type: item.EnclosureType
            },
            itunesAuthor: item.Author,
            itunesExplicit: false,
            itunesSummary: item.Description,
            itunesImage: item.ImageUrl,
            itunesSeason: parseInt(item.Season || '0'),
            itunesDuration: item.Duration,
            itunesNewFeedUrl: item.FeedLink
        })
    })

    rssStr = feed.buildXml()

    return rssStr
}